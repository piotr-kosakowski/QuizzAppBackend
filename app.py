import os
import tempfile
import uuid
from functools import wraps

import firebase_admin
from firebase_admin import credentials, auth
from flask import Flask, request, jsonify
from flask_cors import CORS
from google.cloud import datastore

credentials_json_content = os.environ.get("CREDENTIALS_JSON")

if credentials_json_content:
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.json', delete=False) as temp_file:
        temp_file.write(credentials_json_content)
        credentials_path = temp_file.name
else:
    credentials_path = "credentials.json"

cred = credentials.Certificate("credentials.json")
firebase_admin.initialize_app(cred)

datastore_client = datastore.Client.from_service_account_json("credentials.json", project="cc-project-457519")
app = Flask(__name__)
CORS(app, origins=["http://localhost:3000"])


# curl -X POST -H "Content-Type: application/json" -d '{"email": "test@example.com", "password":"secret123"}' http://localhost:5000/register


def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return jsonify({'error': 'No authorization header'}), 401

        parts = auth_header.split()
        if parts[0].lower() != 'bearer' or len(parts) != 2:
            return jsonify({'error': 'Wrong authorization header'}), 401

        token = parts[1]
        try:
            decoded_token = auth.verify_id_token(token)
            request.user = decoded_token
        except Exception as e:
            return jsonify({'error': 'Wrong or expired token'}), 401

        return f(*args, **kwargs)

    return decorated


@app.route('/register', methods=['POST'])
def register():
    """
    Registers a new user using Firebase Authentication.
    Expected JSON data: {"email": "example@gmail.com", "password": "password123"}
    """
    data = request.get_json()
    print(data)
    email = data.get('email')
    password = data.get('password')

    if not email or not password:
        return jsonify({'error': 'Email and password are required'}), 400

    try:
        user_record = auth.create_user(email=email, password=password)
        return jsonify({'message': 'User registered', 'uid': user_record.uid}), 201
    except Exception as e:
        return jsonify({'error': str(e)}), 400


@app.route('/login', methods=['POST'])
def login():
    """
    Logs in a user by verifying the provided token (generated by Firebase Client SDK).
    Expected JSON data: {"idToken": "token"}
    """
    data = request.get_json()
    id_token = data.get('idToken')
    if not id_token:
        return jsonify({'error': 'Token is needed to login'}), 400

    try:
        decoded_token = auth.verify_id_token(id_token)
        uid = decoded_token.get('uid')
        return jsonify({'message': 'Logged in', 'uid': uid}), 200
    except Exception as e:
        return jsonify({'error': 'Wrong or expired token'}), 401


@app.route('/sets', methods=['POST'])
@token_required
def create_set():
    """
    Creates a new set
    Expected JSON: {"title": "set title", "description": "set description"}
    Requires a valid token in the authorization header.
    """
    data = request.get_json()
    title = data.get('title')
    description = data.get('description', '')
    if not title:
        return jsonify({'error': 'Title is needed'}), 400

    set_id = str(uuid.uuid4())
    key = datastore_client.key('Set', set_id)
    entity = datastore.Entity(key=key)
    entity.update({'set_id': set_id, 'title': title, 'description': description, 'created_by': request.user.get('uid')})

    datastore_client.put(entity)
    return jsonify({'message': 'Set created', 'set_id': set_id}), 201


@app.route('/sets', methods=['GET'])
@token_required
def list_sets():
    """
    Returns all sets, authorization is required
    """
    query = datastore_client.query(kind='Set')
    results = list(query.fetch())
    return jsonify(results), 200


@app.route('/sets/<set_id>', methods=['PUT'])
@token_required
def update_set(set_id):
    """
    Updates an existing set.
    Expected JSON: { "title": "New title", "description": "New description" }
    """
    data = request.get_json()
    title = data.get('title')
    description = data.get('description')
    key = datastore_client.key('Set', set_id)
    entity = datastore_client.get(key)
    if entity is None:
        return jsonify({'error': 'Set does not exist'}), 404

    if title:
        entity['title'] = title

    if description:
        entity['description'] = description

    datastore_client.put(entity)
    return jsonify({'message': 'Set updated'}), 200


@app.route('/sets/<set_id>', methods=['DELETE'])
@token_required
def delete_set(set_id):
    """
    Usuwa set â€“ wymaga autoryzacji
    """
    key = datastore_client.key('Set', set_id)
    entity = datastore_client.get(key)

    if entity is None:
        return jsonify({'error': 'Set does not exist'}), 404

    datastore_client.delete(key)
    return jsonify({'message': 'Set deleted'}), 200


@app.route('/sets/<set_id>/items', methods=['POST'])
@token_required
def create_item(set_id):
    """
    Creates a new item within a set.
    Expected JSON: {"term": "word", "definition": "definition"}
    """
    data = request.get_json()
    term = data.get('term')
    definition = data.get('definition')
    if not term or not definition:
        return jsonify({'error': 'Term and definition are needed'}), 400

    item_id = str(uuid.uuid4())
    # klucz hierarchiczny - rodzic to encja Set
    parent_key = datastore_client.key('Set', set_id)
    key = datastore_client.key('Item', item_id, parent=parent_key)
    entity = datastore.Entity(key=key)
    entity.update({'item_id': item_id, 'term': term, 'definition': definition})
    datastore_client.put(entity)
    return jsonify({'message': 'Item created', 'item_id': item_id}), 201


@app.route('/sets/<set_id>/items', methods=['GET'])
@token_required
def list_items(set_id):
    """
    Returns all items for a given set
    """
    parent_key = datastore_client.key('Set', set_id)
    query = datastore_client.query(kind='Item', ancestor=parent_key)
    results = list(query.fetch())
    return jsonify(results), 200


@app.route('/sets/<set_id>/items/<item_id>', methods=['PUT'])
@token_required
def update_item(set_id, item_id):
    """
    Updates an item within a set.
    Expected JSON: { "term": "New term", "definition": "New definition" }
    """
    data = request.get_json()
    term = data.get('term')
    definition = data.get('definition')
    parent_key = datastore_client.key('Set', set_id)
    key = datastore_client.key('Item', item_id, parent=parent_key)
    entity = datastore_client.get(key)

    if entity is None:
        return jsonify({'error': 'Item does not exist'}), 404

    if term:
        entity['term'] = term

    if definition:
        entity['definition'] = definition

    datastore_client.put(entity)
    return jsonify({'message': 'Item updated'}), 200


@app.route('/sets/<set_id>/items/<item_id>', methods=['DELETE'])
@token_required
def delete_item(set_id, item_id):
    """
    Deletes an item within a set.
    """
    parent_key = datastore_client.key('Set', set_id)
    key = datastore_client.key('Item', item_id, parent=parent_key)
    entity = datastore_client.get(key)

    if entity is None:
        return jsonify({'error': 'Item does not exist'}), 404
    datastore_client.delete(key)
    return jsonify({'message': 'Item deleted'}), 200


if __name__ == '__main__':
    app.run(debug=True)
